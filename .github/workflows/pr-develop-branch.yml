name: Ejecutar automatizaciÃ³n de PR en ambiente develop
# Definition when the workflow should run
on:
    # The workflow will run whenever an event happens on a pull request
    pull_request:
      types: [closed]
      branches: [ develop ]
      paths:
        - 'force-app/**'

jobs:
  Explore-GitHub-Actions:
    runs-on: ubuntu-latest
    steps:
      - run: echo "ðŸŽ‰ The job was automatically triggered by a ${{ github.event_name }} event."
      - run: echo "ðŸ§ This job is now running on a ${{ runner.os }} server hosted by GitHub!"
      - run: echo "ðŸ”Ž The name of your branch is ${{ github.ref }} and your repository is ${{ github.repository }}."
      - name: Check out repository code
        uses: actions/checkout@v3

      - run: echo "ðŸ’¡ The ${{ github.repository }} repository has been cloned to the runner."
      - run: echo "ðŸ–¥ï¸ The workflow is now ready to test your code on the runner."
      - name: List files in the repository
        run: |
          ls ${{ github.workspace }}
      - run: echo "ðŸ This job's status is ${{ job.status }}."
  
  InicioDespliegue:
    runs-on: ubuntu-latest
    needs: [Explore-GitHub-Actions]
    env:
      Secreto: ${{ secrets.SERVERKEY}}
      CLIENT_ID: ${{ secrets.CLIENT_ID }}
      INSTANCE_URL:  ${{ secrets.URL }}
      SF_USERNAME:  ${{ secrets.SF_USERNAME }}    
    steps:
      # Checkout the Source code from the latest commit
      - name: Checkout code
        uses: actions/checkout@v4
        with:
           fetch-depth: 0
           
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22.11.0'
          
      - name: Install the SF CLI
        run: |
          npm install @salesforce/cli --global

      - name: Install sfdx-git-delta
        run: echo 'y' | sfdx plugins:install sfdx-git-delta

      - name: Create delta directory
        run: mkdir ./manifestdelta

      - name: Check changes
      #  run: sfdx sgd:source:delta --to HEAD --from HEAD~1 -o ./delta_source -d -s force-app/
        run: sfdx sgd:source:delta --to HEAD --from HEAD~1 -o ./manifestdelta -d -s force-app/
      
      - name: Show package.xml
        #run: cat ./delta_source/package/package.xml
        run: cat ./manifestdelta/package/package.xml
#este se borra
      - name: Show destructiveChanges.xml
        run: cat ./manifest/package/destructiveChangesPost.xml
#Fin de se borra

      - name: List files in the repository
        run: |
         ls ${{ github.workspace }}

      - name: create folder
        run: 
          mkdir -p ./key

      - name: Authenticate with Salesforce CLI using JWT flow
        run: |
           echo "${Secreto}" > ./key/server.key
           sf org login jwt --username  ${{ env.SF_USERNAME }} --jwt-key-file "./key/server.key" --client-id ${{ env.CLIENT_ID }} --instance-url ${{ env.INSTANCE_URL }}  --alias develop --set-default  --json 
      
      - name: Verify Authentication
        run: |
          sf org list
          
      #- name:  ValidaciÃ³n de Codigo 
       # run:
        # sf project deploy validate --manifest "./manifestdelta/package/package.xml" --target-org develop
 
      - name: Deploy Salesforce
        run: 
          sf project deploy start --manifest "./manifestdelta/package/package.xml" --post-destructive-changes "./manifest/package/destructiveChangesPost.xml"  --target-org develop --ignore-conflicts 

    #  - name: Deploy destructiveChanges 
     #   run: 
      #    sf project deploy start --post-destructive-changes "./manifest/package/destructiveChangesPost.xml"  --target-org develop --ignore-conflicts 
    
      - name: Install the SFDX CLI Scanner
        run: |
          echo 'y' | sf plugins install @salesforce/sfdx-scanner
      
      - name: Create reports directory
        run: mkdir -p reports

      - name: Run SFDX CLI Scanner 
        run: |
          sf scanner run -f html -t "./force-app" -e "eslint,retire-js,pmd,cpd" -c "Design,Best Practices,Code Style,Performance,Security" --outfile reports/scan-reports.html 
     
      - uses: actions/upload-artifact@v4
        with:
            name: cli-scan-report
            path: reports/scan-reports.html

  MensajeSlack:
    runs-on: ubuntu-latest
    needs: [Explore-GitHub-Actions]
    steps:
      - name: Send custom event details to a Slack workflow
        uses: slackapi/slack-github-action@v2.0.0
        with:
          webhook: ${{ secrets.SLACK_WEBHOOK_URL }}
          webhook-type: webhook-trigger
          payload: |
            status: "${{ job.status }}"
            option: "false"
  
  DeltaComponent:
    runs-on: ubuntu-latest
    needs: [Explore-GitHub-Actions]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
         fetch-depth: 0

      - name: create folder
        run: 
          mkdir -p ./diferencias

      - name: Send custom event details to a Slack workflow
        run: 
          git diff --name-status HEAD~1> "./diferencias/archivosmodificados.txt"
      - name: List files in the repository
        run: |
          ls ${{ github.workspace }}
      - name: Run PowerShell script
        run: |
          $sourcePath = "${{ github.workspace }}/"
          $diffFilePath = "${{ github.workspace }}/diferencias/archivosmodificados.txt"
          $linesFile = Get-Content -Path $diffFilePath
          function FilterAndCopyFiles {
          param (
          $linesFile,
          [string] $originPath,
          [string] $targetPath
          )
          Write-Host '**** Funcion FilterAndCopyFiles *******'
          $filesCount = @{ result = 0 }
          $finalSourcePath = ''
          $finalTargetPath = ''
          $path_datapack = @()
          foreach ($line in $linesFile) {
          if ($line -match '[D,M,A,R]\d{0,4}\tdataPack\/.*$' -or $line -match '[D,M,A,R]\d{0,4}\tforce-app\/.*$') {
          if ($line -match '[R]\d{0,4}\tdataPack\/.*$' -or $line -match '[R]\d{0,4}\tforce-app\/.*$') {
          $line_split = $line.split("`t")
          $status_line = $line_split[0]
          $path_file = $line_split[2]
          } else {
          $line_split = $line.split("`t")
          $status_line = $line_split[0]
          $path_file = $line_split[1]
          }
          $finalSourcePath = $originPath + $path_file
          $finalTargetPath = $targetPath + $path_file
          if ($path_file -match 'dataPack\/[^\/]+\/[^\/]+\/') {
          Write-Host "`tEn dataPack:" -ForegroundColor Yellow
          $componentFolder = $path_file -replace '^(dataPack\/[^\/]+\/[^\/]+)\/.*$', '$1'
          $componentPath = $originPath + $componentFolder
          $destinationComponentPath = $targetPath + $componentFolder
          $destinationComponentPath = Split-Path $destinationComponentPath -Parent
          if (-not ($path_datapack.Contains($componentFolder)) -and (Test-Path -Path $componentPath)) {
          if (-not (Test-Path -Path $destinationComponentPath)) {
          New-Item -ItemType Directory -Force -Path $destinationComponentPath
          }
          Copy-Item -Path $componentPath -Destination $destinationComponentPath -Recurse -Force
          $path_datapack += $componentFolder
          Write-Host "Copiada ruta: $componentFolder"
          $filesCount.result++
          }
          } elseif ($path_file -match 'force-app\/[^\/]+\/[^\/]+\/classes+\/' -or $path_file -match 'force-app\/[^\/]+\/[^\/]+\/triggers+\/') {
          if ($status_line -ne "D") {
          $componentFolder = $path_file -replace '^(force-app\/[^\/]+\/[^\/]+\/classes\/)(.*$)', '$1'
          $fileName = $path_file -replace '^(force-app\/[^\/]+\/[^\/]+\/classes\/)(.*$)', '$2'
          $fileName = $fileName.split(".")[0]
          Write-Host "`tforce-app (classes - triggers)" -ForegroundColor Yellow
          $componentPath = $originPath + $componentFolder + $fileName + ".*"
          $destinationComponentPath = $targetPath + $componentFolder
          if (-not (Test-Path -Path $destinationComponentPath)) {
          New-Item -ItemType Directory -Force -Path $destinationComponentPath
          }
          Copy-Item -Path $componentPath -Destination $destinationComponentPath -Recurse
          $filesCount.result
      
     
        
